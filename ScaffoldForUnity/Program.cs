using System;
using System.Linq;
using System.IO;
using System.Reflection;
using WrongWarp;

namespace ScaffoldForUnity
{
    class Program
    {
        static void Main(string[] args)
        {
            string dstPath = @"E:\Projects\OuterWildsMod\OuterWildsUnityTemplate\Assets\ModScripts\WrongWarp";

            if (Directory.Exists(dstPath))
                Directory.Delete(dstPath, true);

            Assembly asm = typeof(WrongWarpMod).Assembly;

            foreach (var t in asm.GetExportedTypes())
            {
                if (t.IsNested) continue;

                var name = t.Name;
                if (t.IsGenericTypeDefinition)
                {
                    name = name.Substring(0, name.IndexOf('`'));
                    name += "<" + string.Join(", ", t.GetGenericArguments().Select(a => a.Name)) + ">";
                }

                if (IsClassLike(t) || t.IsEnum)
                {
                    string output = "///AUTO-GENERATED BY ScaffoldForUnity. DO NOT MODIFY.\n";

                    OutputNamespace(t, ref output, 0, () =>
                    {
                        if (IsClassLike(t))
                        {
                            OutputClass(t, ref output, 1, () =>
                            {

                            });

                        } else if (t.IsEnum)
                        {
                            OutputEnum(t, ref output, 1);
                        }
                    });

                    string ns = t.Namespace.Replace('.', '\\');
                    string fileName = name.Replace('<', '_').Replace(">", "") + ".cs";
                    string fileDir = Path.Combine(dstPath, ns);
                    string filePath = Path.Combine(fileDir, fileName);

                    Directory.CreateDirectory(fileDir);

                    File.WriteAllText(filePath, output);
                }
            }
        }

        static string GetPrintableName(Type t)
        {
            var name = t.Name;
            if (t.IsGenericTypeDefinition)
            {
                name = name.Substring(0, name.IndexOf('`'));
                name += "<" + string.Join(", ", t.GetGenericArguments().Select(a => GetPrintableName(a))) + ">";
            } else if (t.IsGenericType)
            {
                name = name.Substring(0, name.IndexOf('`'));
                name += "<" + string.Join(", ", t.GetGenericArguments().Select(a => GetPrintableTypeName(a))) + ">";
            }
            return name;
        }

        static string GetPrintableTypeName(Type t)
        {
            if (string.IsNullOrEmpty(t.Namespace) && t.IsSubclassOf(typeof(UnityEngine.Component))) return "UnityEngine.Component";

            if (t.IsNested) return $"{GetPrintableTypeName(t.DeclaringType)}.{GetPrintableName(t)}";
            if (string.IsNullOrEmpty(t.Namespace)) return GetPrintableName(t);
            return $"{t.Namespace}.{GetPrintableName(t)}";
        }

        static string GetIndent(int indentLevel)
        {
            return new string(' ', indentLevel * 4);
        }

        static void OutputNamespace(Type t, ref string o, int d, Action body)
        {
            o += $"{GetIndent(d)}namespace {t.Namespace} {{\n";
            body();
            o += $"{GetIndent(d)}}}\n";
        }

        static void OutputClass(Type t, ref string o, int d, Action body)
        {
            var name = GetPrintableName(t);
            var keyword = t.IsClass ? "class" : t.IsInterface ? "interface" : t.IsValueType ? "struct" : "?";

            var parentClass = t.BaseType != null &&
                t.BaseType != typeof(object) &&
                t.BaseType != typeof(ValueType) &&
                t.BaseType != typeof(MulticastDelegate) &&
                t.BaseType != typeof(OWML.ModHelper.ModBehaviour) ?
                    $": {GetPrintableTypeName(t.BaseType)} " :
                    "";

            if (t.GetCustomAttribute<SerializableAttribute>() != null)
            {
                o += $"{GetIndent(d)}[System.Serializable]\n";
            }

            o += $"{GetIndent(d)}public partial {keyword} {name} {parentClass}{{\n";
            foreach (var f in t.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                OutputField(f, ref o, d + 1);
            }
            foreach (var p in t.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                OutputProperty(p, ref o, d + 1);
            }

            body();

            foreach (var n in t.GetNestedTypes())
            {
                if (IsClassLike(n))
                {
                    OutputClass(n, ref o, d + 1, () =>
                    {

                    });
                } else if (n.IsEnum)
                {
                    OutputEnum(n, ref o, d + 1);
                }
            }
            o += $"{GetIndent(d)}}}\n";
        }

        static void OutputField(FieldInfo f, ref string o, int d)
        {
            var name = f.Name;
            var type = GetPrintableTypeName(f.FieldType);
            var keywords = f.IsInitOnly ? "readonly " : "";
            if (string.IsNullOrEmpty(f.FieldType.Namespace) && f.FieldType.IsSubclassOf(typeof(UnityEngine.Component)))
                o += $"{GetIndent(d)}[OWComponent(\"{f.FieldType.Name}\")]\n";
            o += $"{GetIndent(d)}public {keywords}{type} {name};\n";
        }

        static void OutputProperty(PropertyInfo p, ref string o, int d)
        {
            var name = p.Name;
            var type = GetPrintableTypeName(p.PropertyType);
            var getter = p.CanRead ? "get; " : "";
            var setter = p.CanWrite ? "set; " : "";
            if (string.IsNullOrEmpty(p.PropertyType.Namespace) && p.PropertyType.IsSubclassOf(typeof(UnityEngine.Component)))
                o += $"{GetIndent(d)}[OWComponent(\"{p.PropertyType.Name}\")]\n";
            o += $"{GetIndent(d)}public {type} {name} {{ {getter}{setter}}}\n";
        }

        static void OutputEnum(Type t, ref string o, int d)
        {
            var name = GetPrintableName(t);
            var type = GetPrintableTypeName(t.GetEnumUnderlyingType());
            o += $"{GetIndent(d)}public enum {name} : {type} {{\n";
            var names = Enum.GetNames(t);
            var values = Enum.GetValues(t).Cast<int>().ToArray();
            for (var i = 0; i < names.Length; i++)
            {
                o += $"{GetIndent(d + 1)}{names[i]} = {values[i]},\n";
            }
            o += $"{GetIndent(d)}}}\n";
        }


        static bool IsClassLike(Type t)
        {
            return t.IsClass || t.IsInterface || (t.IsValueType && !t.IsPrimitive && !t.IsEnum);
        }
    }
}
